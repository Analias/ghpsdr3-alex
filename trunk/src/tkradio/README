This is a Tcl/Tk script that behaves as a UI for the ghpsdr-alex3
dspserver backend and adds a few bells and whistles.

This requires the following packages on Ubuntu 15.10 and later:

      sudo apt-get install tcl tk tcl-snack tcl-tls

Snack may provide audio input and output, it's sort of old at this
point in its life.

tcl-tls may provide the secure socket layer, it's the library that
does this, but I don't know if I want to worry about that.

The bells and whistles specifically planned were to provide a rapid
multi-client mode that would cause dspserver to crash.  Then I'd like
a testbed for decoding multiple channels, but that's going to require
modifications to dspserver and DttSP beyond curing their crashes.
------------------------------------------------------------------------
Discovered while debugging the packet receive loop in tkradio that the
audio packets sent by dspserver are occasionally 1 or 2 bytes short.
There is no way this can happen in the dspserver code except if the
event_buffer code occasionally short changes the socket.  I have
instrumented the dspserver code with printfs to detect a short count
in the three places where the length gets touched.  The tkradio
receive loop continues to report short packets while the dspserver
printfs report no shortage.

If you assume that each packet read from the socket is the whole of a
write to the other end of the socket, then you can sort of ignore the
issue.  I just spent a while reading the QtRadio/Connection.cpp code
and decided that I cannot tell whether it notices if packets are short
or not.

I suppose this could be a Tcl issue, too.  I guess I could write a
simple C program to test the question faster than figuring out whether
QtRadio is correct.

...

It is a Tcl issue, the c program only read two packets that were not
complete audio or spectrum buffers, and those two packets were a
complete audio and a compete spectrum buffer coalesced into one read.

Okay, so how would Tcl lose one or two bytes per buffer?  \r\n
processing, set -translation binary and see what we get.  Looks like
we get perfect buffer processing.
------------------------------------------------------------------------
The structure I'm thinking of is to push different connections into
different notebook tabs.  But part of the radio structure is probably
common to all the tabs?  Or is it?

So start up and make a connection, if one is specified, but present a
menu which allows new connections to be opened or closed, and allow
one or more of the connections to send audio to the local output
device.

A receiver has a radio server host, port, frequency, a mode, and a
filter bandwidth.  Then there is a long list of optional stuff.

Now you might think that the output audio device was common across the
radios opened, but that would ignore that some radios could be
interfaced to sound card digital modes while others are playing their
audio directly, or that some could be split to both audio and digital
decoding, as one might do with CW.
------------------------------------------------------------------------
How to organize this?  Well, we have different services in the radio
spectrum: broadcast, amateur, aviation, marine, commercial, citizen,
and so on.  Each of these services has bands.  Each band has a number
of fixed channels with known modes and a number of saved channels with
last tuned frequency and mode.  

When the radio loads a service, it makes a menu of bands available and
loads the last loaded band. So there's a memory along side the service
/ band / channel database which records personal usage.  Similarly
loading a band finds the memory of the last tuned frequency / mode /
filter settings, and prepares the other memorized channels for the
band for scanning.  The fixed channels are probably displayed on the
frequency display with some kind of marker as are the memoized
channels.
