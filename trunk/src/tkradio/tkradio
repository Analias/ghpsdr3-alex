#!/usr/bin/tclsh
# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2016 by Roger E Critchlow Jr, Cambridge, MA, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

##
## required external packages
##
package require Tcl;		# sudo apt-get install tcl
package require snit;		# sudo apt-get install tcllib

##
## required internal packages
##
package require sdrtype::types;	# snit types for option checking
package require sdr::radio;	# the dspserver radio model
package require sdr::server;	# the napan.com servers listing
package require sdr::connect;	# the tcp connection to dspserver
package require sdr::command;	# the commands sent to dspserver
package require sdr::audio;	# audio playback (no mike as yet)
#package require sdr::filter;	# our filter syntax
#package require sdr::util;	# various utilities

package require sdr::band-data;	# service and band information
package require sdr::memory;	# memories for the radio

snit::enum audio-format -values {ALAW:8000 PCM:48000}

snit::type tkradio {
    option -id -default {tkradio}
    option -ui -configuremethod Configure			
    option -hw -configuremethod Configure
    option -verbose -default 0 -configuremethod Configure2
    option -name -configuremethod Configure2
    option -name-values -configuremethod Configure2
    option -audio-format -default ALAW:8000 -type audio-format
    option -connect-status {}
    option -sample-rate -default 3000 -configuremethod Configure2;	# -sample-rate of dspserver from spectrum
    option -local-oscillator -default 0 -configuremethod Configure2;	# -local-oscillator of dspserver from spectrum

    component server
    component connect
    component command
    
    component radio
    component hw
    component ui
    component hwui

    variable data -array {
	tickle-spectrum {}
	tickle-master {}
	tickle-cantx {}
	meter-listeners {}
	spectrum-listeners {}
	spectrum-xs {}
	spectrum-sr 0
	spectrum-n 0
    }
    
    constructor {args} {
	install server using sdr::server $self.server -parent $self
	install connect using sdr::connect $self.connect -parent $self
	install command using sdr::command $self.command -parent $self
	install radio using sdr::radio $self.radio -parent $self
	$radio configure -service [sdr::get-last service]
	$server request [list {*}[mymethod configure] -name-values]
	# initialize connections
	$connect add-listener status [mymethod connect-status]
	$connect add-listener spectrum [mymethod process-spectrum]
	$connect add-listener answer [mymethod process-answer]
    }

    ##
    ## found this method buried in QtRadio
    ##
    ## it used to poll for spectrum buffers before the setfps command
    ## made that obsolete.  then it was overloaded to check for master
    ## status 
    ## then it was overloaded 
    ## to count to 25 and send "q-master" and "q-info" and
    ## to count to 50 and send "q-cantx#user"
    ##
    ## this periodic tickling may help keep things ticking
    ## if pollspectrum is set
    ##    the getspectrum happens at 
    ## assuming 10 fps spectrum polling, 100 ms per poll,
    ## the q-master polling happens at 2500 ms
    ## if chkTX is set, the q-cantx#user polling happens at 5000 ms
    ##
    method tickle {} {
	if {$pollspectrum} {
	    $self.command getspectrum $option(-spectrum-width)
	}
	if {$infotick > 25} {
	    $self.command q-master
	    if {$amslave} { $self.command q-info }
	    set infotick 0
	}
	if {$infotick2 == 0} {
	    ## set to 0 wehen we first connect
	    if {$chkTX} {
		$self.command q-cantx user ## can we tx here?
	    }
	} elseif {$infotick2 > 50} {
	    if {$chkTX} {
		$self.command q-cantx user ## can we tx here?
	    }
	    set infotick2 0
	}
	incr infotick
	incr infotick2
    }

    method {Configure -ui} {val} {
	if {$options(-ui) ne {}} {
	    # destroy the old ui
	}
	set options(-ui) $val
	if {[catch {package require sdrui::$val-radio} error]} {
	    puts stderr "cannot require package sdrui::$val-radio"
	    return
	}

	# if the -ui loaded Tk
	if { ! [catch {package present Tk} error]} {
	    # setup theming
	    # source sdr/theme-alt.tcl
	    ttk::style theme create night
	    if {[catch {package require ttk::theme::night} error]} {
		puts stderr "cannot require package ttk::theme::night"
	    } else {
		ttk::style theme use night
	    }
	    # build the graphical ui
	    pack [sdrui::$val-radio .radio -parent $self] -fill both -expand true
	    set ui .radio
	} else {
	    # build the non-graphical ui
	    set ui [sdrui::$val-radio $self.ui -parent $self]
	}
    }

    method {Configure -hw} {value} {
	if {$options(-hw) ne $value} {
	    if {$options(-hw) eq {} && $value ne {}} {
		# load hardware component
		set hardware sdr::radio-$value
		if {[catch {package require $hardware} error]} {
		    # no such hardware module
		    puts stderr "package require $hardware failed: $error"
		    return
		}
		# initialize hardware component, 
		if {[catch {$hardware $self.hw -parent $self} error]} {
		    # failed to create hardware handler
		    puts stderr "$hardware -radio $self failed: $error"
		    return
		}
		# mark it as installed
		set options(-hw) $value
		set hw $self.hw

		# now do the matching ui component
		# if there is one!
		if {$options(-ui) ne {}} {
		    $self install-hwui
		}
	    } elseif {$options(-hw) ne {} && $value eq {}} {
		set options(-hw) $value
		catch {rename $hw {}}
		set hw {}

		$ui unmap-hardware
		destroy $hwui
		set hwui {}
	    } else {
		puts stderr "Configure -hw {$value} when options(-hw) is {$options(-hw)}???"
	    }
	}
    }

    method Configure2 {option value} {
	if {$options($option) ne $value} {
	    set options($option) $value
	}
    }

    method install-hwui {} {
	set hardwareui sdrui::$options(-ui)-radio-$options(-hw)
	# load hardware ui package
	if {[catch {package require $hardwareui} error]} {
	    # no such hardware ui module
	    puts stderr "package require $hardwareui failed: $error"
	    return
	}
	# create hardware ui widget
	if {[catch {$hardwareui $ui.hw -parent $self} error]} {
	    puts stderr "$hardwareui $ui.hw -parent $self failed: $error"
	    return
	}
	# map it into the ui
	if {[catch {$ui map-hardware} error]} {
	    puts stderr "$hardwareui failed to map"
	    rename $ui.hw {}
	    return
	}
	# save the component
	set hwui $ui.hw
    }

    method verbose-puts {msg} {
	if {$options(-verbose)} { puts stderr $msg }
    }
    method get-audio-sample-format {} {
	return [lindex [split $options(-audio-format) :] 0]
    }
    method get-audio-sample-rate {} {
	return [lindex [split $options(-audio-format) :] 1]
    }
    ##
    method connect {} {
	if {[$connect is-connected]} { error "socket is already connected" }
	$connect connect {*}[$server address-port $options(-name)]
	$connect add-listener audio audio-out-data
	audio-out-start [$self get-audio-sample-format] [$self get-audio-sample-rate]
	$radio connect
	$self tickle-master
	# only do this if there's a transmitter attached
	# I suspect that is the meaning of the N in one of the connection messages
	# $self tickle-cantx
    }

    method disconnect {} {
	if { ! [$connect is-connected]} { error "socket is not connected" }
	# verbose-puts "disconnecting self = $self"
	$radio disconnect
	$connect disconnect
	$connect sub-listener audio audio-out-data
	audio-out-stop
    }
    # toggle the connection state
    method connecttoggle {} {
	if { ! [$connect is-connected]} {
	    if {[catch {$self connect} error]} {
		puts stderr "error in connect: $error\n$::errorInfo"
		$self connect-status $error
	    } else {
		$self connect-status {connected}
	    }
	} else {
	    if {[catch {$self disconnect} error]} {
		puts stderr "error in disconnect: $error\n$::errorInfo"
		$self connect-status $error
	    } else {
		$self connect-status {disconnected}
	    }
	}
	return [$connect is-connected]
    }

    method connect-status {status} {
	switch $status {
	    * {
		puts stderr "connect status: $status"
		$self configure -connect-status {unknown error}
		# $radio disconnect
	    }
	}
    }
    
    # these background loops probe the connection
    # for failure and collect useful status information
    method tickle-spectrum {} {
	if {[catch {getspectrum $options(-spectrum-width)} error]} {
	    $self connect-status $error
	} else {
	    set data(tickle-spectrum) [after [expr {int(1000/$options(-spectrum-fps))}] [mymethod tickle-spectrum]]
	}
    }
    
    method tickle-master {} {
	if {[catch {$command q-master; $command q-info} error]} {
	    $self connect-status $error
	} else {
	    set data(tickle-master) [after 2000 [mymethod tickle-master]]
	}
    }

    method tickle-cantx {} {
	if {[catch {$command cantx $options(-user)} error]} {
	    $self connect-status $error
	} else {
	    set data(tickle-cantx)  [after 4000 [mymethod tickle-cantx]]
	}
    }

    ##
    ## incoming packets from dspserver
    ##
    
    # process spectrum records received from the server
    method process-spectrum {main sub sr lo spectrum} {
	# spectrum record
	# coming at the frame rate specified by setfps
	# with the number of samples specified by setfps
	# each sample is an unsigned byte which is the bin level
	# measured as the dB's below zero
	
	# store some values as configuration options because
	# they rarely change
	$self configure -sample-rate $sr -local-oscillator $lo
	# pass the rest into update methods that can be subscribed
	$self meter-update $main $sub
	$self spectrum-update {*}[$self xy $spectrum]
	update idletasks
    }
    # convert incoming spectrum string from unsigned -dB in bytes
    # into freq dB coordinates as floats
    method xy {ystr} {
	binary scan $ystr {c*} ys
	# last byte is always 0
	set ys [lrange $ys 0 end-1]
	set n [llength $ys]
	# recompute the x coordinates for the spectrum
	if {$n != $data(spectrum-n) || $options(-sample-rate) != $data(spectrum-sr)} {
	    set data(spectrum-n) $n
	    set sr [set data(spectrum-sr) $options(-sample-rate)]
	    set data(spectrum-xs) {}
	    set maxf [expr {$sr/2.0}]
	    set minf [expr {-$maxf}]
	    set df [expr {double($sr)/$n}]
	    set data(spectrum-xs)
	    for {set i 0} {$i < $n} {incr i} {
		lappend data(spectrum-xs) [expr {$minf+$i*$df}]
	    }
	}
	set xs $data(spectrum-xs)
	# this is how QtRadio extracts the spectrum bytes
	set ys [lmap y $ys {expr {-($y&0xff)}}]
	# keep min, max, and average levels
	set miny [tcl::mathfunc::min {*}$ys]
	set maxy [tcl::mathfunc::max {*}$ys]
	set avgy [expr {[tcl::mathop::+ {*}$ys]/double($n)}]
	
	set xy {}
	foreach x $xs y $ys {
	    lappend xy $x $y
	}
	return [list $xy $miny $maxy $avgy]
    }
    # process answers to queries to the dspserver
    method process-answer {answer} {
	switch -glob $answer {
	    {q-server:*} {
		# parse out server name and can-tx?
	    }
	    {\*hardware\? OK *} {
		# set up hardware specific model and ui
		$self configure -hw [string tolower [lindex $answer end]]
	    }
	    {\*setattenuator*} {
	    }
	    default {
		puts stderr "answer = {$answer}"
	    }
	}
    }
    ##
    ## manage listeners
    ##
    # listen for meter updates
    method meter-subscribe {callback} {
	lappend data(meter-listeners) $callback
    }
    method meter-update {main subrx} {
	foreach callback $data(meter-listeners) { {*}$callback $main $subrx }
    }
    # listen for spectrum updates
    method spectrum-subscribe {callback} {
	lappend data(spectrum-listeners) $callback
    }
    method spectrum-update {xy miny maxy avgy} {
	foreach callback $data(spectrum-listeners) { {*}$callback $xy $miny $maxy $avgy }
    }

    ##
    ## monitor our configuration options
    ## 
    method monitor {opts prefix} {
	foreach opt $opts {
	    trace variable options($opt) w [list {*}[mymethod monitor-fired] $prefix]
	}
    }

    method monitor-fired {prefix name1 name2 op} {
	{*}$prefix $name2 $options($name2)
    }

    # process a command line argument
    method optarg {opt} {
	upvar argc argc argv argv i i
	if {$i == $argc-1} { 
	    set list {}
	    switch -- $opt {
		-audio-format { set list {ALAW:8000 PCM:48000} }
		-server { set list [$server get-names] }
		-service { set list [sdr::band-data-services] }
		-band { set list [$radio cget -band-values] }
		-mode {	set list [$radio cget -mode-values] }
		-filter { set list [$radio cget -filter-values] }
	    }
	    if {$list ne {}} {
		set e "missing arg for $opt option: $list"
	    } else {
		set e "missing arg for $opt option"
	    }
	    error $e
	}
	set val [lindex $argv [incr i]]
	# $self verbose-puts "optarg $opt found $val"
	switch -- $opt {
	    -local { $server add-local {*}$val }
	    default { $self configure $opt $val }
	}
    }

    # process command line arguments to the tkradio script
    method process-argv {argv} {
	if {[catch {
	    set argc [llength $argv]
	    if {$argc == 0} {
		# make a command line
		set argv {-n local -l {local localhost 8000} -u pw}
		set argc [llength $argv]
	    }
	    # load saved configuration, including current options, saved memories,
	    # and last tuned points
	    
	    # specify options
	    for {set i 0} {$i < $argc} {incr i} {
		# accumulate arguments
		set opt [lindex $argv $i]
		switch -- $opt {
		    --					{ continue }
		    -a - --audio-format			{ $self optarg -audio-format }
		    -b - --band				{ $self optarg -band }
		    -c - --connect			{ $self.radio connect }
		    -e - --filter			{ $self optarg -filter }
		    -f - --frequency			{ $self optarg -frequency }
		    -l - --local - --local-server	{ $self optarg -local }
		    -m - --mode				{ $self optarg -mode }
		    -n - --name - --name-of-server	{ $self optarg -name }
		    -s - --service			{ $self optarg -service }
		    -t - --text				{ $self optarg -text }
		    -u - --ui				{ $self optarg -ui }
		    -v - --verbose			{ $self optarg -verbose }
		    default { error "unrecognized option [lindex $argv $i]" }
		}
	    }
	} error]} {
	    if {$options(-verbose)} {
		puts stderr $error\n$::errorInfo\n$usage 
	    } else {
		puts stderr $error$usage
	    }
	    exit 1
	}
    }
    #
    # also want
    #  audio-format ALAW or PCM
    #  audio-sample-rate 8000 or 48000
    #
    variable usage {
usage: tkradio -- <option> [<value>] ...
    --
    -a|--audio-format <format> # is ALAW:8000 or PCM:48000
    -b|--band <band> # <band> is a <service> specific band name
    -c|--connect
    -e|--filter <filter> # <filter> in form 'low .. high'
    -f|--frequency <frequency> # <frequency> in Hertz
    -l|--local|--local-server <local> # <local> in form 'name ip-address port' 
    -m|--mode <mode> # <mode>
    -n|--name|--name-of-server <name> # <name> the name or callsign of a dspserver
    -s|--service <service> # 
    -t|--text <text>
    -u|--ui <ui>
    -v|--verbose <level>
}

}

# create an instance with an automatic name
set tkr [tkradio %AUTO%]
# define a global message reporter
proc verbose-puts {msg} "$tkr verbose-puts \$msg"
# process the command line arguments
$tkr process-argv $argv
if {[$tkr cget -ui] eq {repl}} { vwait forever }
