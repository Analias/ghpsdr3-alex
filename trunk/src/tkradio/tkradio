#!/usr/bin/wish
# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2016 by Roger E Critchlow Jr, Cambridge, MA, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

##
## external packages
##
package require Tk
package require snit
package require snack

##
## our own sdr libraries
##
package require sdr::band-data
package require sdr::command
package require sdr::filter
package require sdr::memory
package require sdr::servers

##
## globals, at least those admitted
##
set radio {};			# radio ui widget
set channel -1;			# socket to dspserver

##
## constants
##
# operating modes
proc get-modes {} { return [::sdr::command::get-modes] }
snit::enum ::modes-type -values [get-modes]
# spectrum modes
proc get-pwsmodes {} { return [::sdr::command::get-pwsmodes] }
snit::enum ::pwsmodes-type -values [get-pwsmodes]

##
## channel handlers
##
namespace eval ::ch {}

proc ::ch::connect {id host port} {
    set chan [socket $host $port]
    chan configure $chan -blocking 0 -encoding binary -translation binary
    fileevent $chan readable [list ::ch::reader $id $chan]
    # fileevent $chan writable [list ::ch::writer $id $chan]
    return $chan
}

proc ::ch::disconnect {id chan} {
    fileevent $chan readable {}
    # fileevent $chan writable {}
    close $chan
}

proc ::ch::reader {id chan} {
    set buffer [read $chan]
    if {[eof $chan]} {
	if {$::verbose > 1} { puts "::ch::reader $id $chan -> eof is true" }
	::ch::disconnect $id $chan
	return
    }
    while {[set len [string length $buffer]] > 0} {
	switch [string index $buffer 0] {
	    \0 {		# spectrum buffer
		if {[binary scan $buffer cccSSSIS type version subversion samples main sub sr lo] != 8} {
		    error "misread spectrum header"
		}
		# puts stderr "spectrum header type $type, version $version, subversion $subversion, samples $samples, main $main, sub $sub, sr $sr, lo $lo"
		set end [expr {15+$samples-1}]
		if {$len < $end} {
		    error "need longer spectrum buffer: $len < $end"
		}
		set data [string range $buffer 15 $end]
		set buffer [string range $buffer $end+1 end]
		$::radio process-spectrum $main $sub $sr $lo $data
		# puts stderr "spectrum $samples bytes, main $main, sub $sub, sr $sr, lo $lo"
		continue
	    }
	    \1 {		# audio
		if {[binary scan $buffer cccS type version subversion samples] != 4} {
		    error "misread audio header"
		}
		# puts "audio buffer type $type, version $version, subversion $subversion, samples $samples"
		set end [expr {5+$samples-1}]
		if {$len < $end} {
		    puts stderr "audio buffer type $type, version $version, subversion $subversion, samples $samples"
		    puts stderr "need a longer audio string: $len < $end"
		}
		set data [string range $buffer 5 $end]
		set buffer [string range $buffer $end+1 end]
		$::radio process-audio $data
		# puts stderr "audio $samples bytes"
		continue
	    }
	    \2 {			# bandscope
		error "bandscope buffer"
	    }
	    \3 {			# rtp reply buffer
		error "rtp-reply buffer"
	    }
	    4 {		# answer buffer
		if {$len < 3} {
		    error "need a longer answer string: $len < 3"
		}
		set samples [scan [string range $buffer 1 2] %d]
		set end [expr {3+$samples}]
		if {$len < $end} {
		    error "need a longer answer string: $len < $end"
		}
		set data [string range $buffer 3 $end-1]
		set buffer [string range $buffer $end end]
		$::radio process-answer $data
		# puts stderr "answer $samples bytes -> {$data}"
		continue
	    }
	    default {
		binary scan $buffer c type
		error "unknown buffer type $type"
	    }
	}
    }
    if {[fblocked $chan]} {
	# puts "::ch::reader $id $chan -> fblocked is true"
	return;
    }
}

proc ::ch::writer {id chan} {
    puts stderr "::ch::writer $id $chan"
}


##
## user interface elements
##
namespace eval ::ui {}
proc maxwidth {list} {
    set widths [lmap s $list {string length $s}]
    return [tcl::mathfunc::max {*}$widths]
}

# an option menu
snit::widgetadaptor ui::optionmenu {
    option -values -default {} -configuremethod Configure
    option -value -default {} -configuremethod Configure
    delegate method * to hull
    delegate option * to hull
    constructor args {
	installhull using ttk::menubutton
	# puts [$self configure]
	# -font {courier 50 bold} 
	# -foreground green -background black 
	$self configure {*}$args
    }
    method {Configure -values} {val} {
	set options(-values) $val
	catch {destroy $win.m}
	$win configure -menu $win.m
	menu $win.m -tearoff no
	foreach v $val {
	    $win.m add radiobutton -label $v -value $v -variable [$self cget -textvar]
	}
	# $self configure -value $options(-value)
    }
    method {Configure -value} {val} {
	set [$self cget -textvar] $val
    }
}

# define a frequency display widget
# G MMM kkk HHH UUU radix point replacing space
# depending on the Unit displayed
snit::widgetadaptor ui::frequency-display {
    variable data -array {
	formatted {}
	width 16
    }
    option -frequency -default 14010000 -type snit::integer -configuremethod Configure
    option -min -default 100000 -configuremethod Configure
    option -max -default 2000000000 -configuremethod Configure
    delegate method * to hull
    delegate option * to hull
    constructor args {
	installhull using ttk::label
	$self configure -width 16 -textvar [myvar data(formatted)] -font {courier 50 bold} -foreground red -background black {*}$args
	$self redraw
	bind $win <ButtonPress> [mymethod button press %x %y %b]
	bind $win <ButtonRelease> [mymethod button release %x %y %b]
	bind $win <MouseWheel> [mymethod button wheel %x %y %D]
    }
    method clamp-frequency {val} {
	return [expr {max($options(-min),min($val,$options(-max)))}]
    }
    method {Configure -frequency} {val} {
	set options(-frequency) [$self clamp-frequency $val]
	$self redraw
    }
    # if the top or bottom of a digit is tapped, increase or lower the value of the digit.
    # but if the release is outside the window then cancel the change.
    # if the blank between digits is tapped, zero the digits to the right.
    method button {t x y etc} {
	switch $t-$etc {
	    press-1 {}
	    release-1 {
		set cy [expr {$y/([winfo height $win]/2)}]
		if {$cy != 0 && $cy != 1} return
		set cx [expr {$x/([winfo width $win]/$data(width))}]
		switch $cx {
		    0 { $self delta 1000000000 $cy }
		    1 { $self zero  1000000000 $cy }
		    2 { $self delta  100000000 $cy }
		    3 { $self delta   10000000 $cy }
		    4 { $self delta    1000000 $cy }
		    5 { $self zero     1000000 $cy }
		    6 { $self delta     100000 $cy }
		    7 { $self delta      10000 $cy }
		    8 { $self delta       1000 $cy }
		    9 { $self zero        1000 $cy }
		    10 { $self delta       100 $cy }
		    11 { $self delta        10 $cy }
		    12 { $self delta         1 $cy }
		    default return
		}
	    }
	    default {
		set cx [expr {$x/([winfo width $win]/17)}]
		set cy [expr {$y/([winfo height $win]/2)}]
		puts "button $t $cx $cy $etc"
	    }
	}
    }
    # change frequency by incrementing or decrementing by $delta
    method delta {delta cy} {
	set f $options(-frequency)
	if {$cy == 1} { set delta [expr {-$delta}] }
	incr f $delta
	$self configure -frequency $f
    }
    # change frequency by zeroing remainder by $zero
    method zero {zero cy} {
	set f $options(-frequency)
	set f [expr {$f - ($f % $zero)}]
	$self configure -frequency $f
    }
    method redraw {} {
	set f $options(-frequency)
	set G [expr {$f / 1000000000}]
	set f [expr {$f % 1000000000}]
	set M [expr {$f / 1000000}]
	set f [expr {$f % 1000000}]
	set k [expr {$f / 1000}]
	set H [expr {$f % 1000}]
	set data(formatted) [format {%1d %03d %03d %03d Hz} $G $M $k $H]
	for {set i 0} {$i < [string length $data(formatted)]} {incr i} {
	    switch [string index $data(formatted) $i] {
		0 {
		    # replace leading zeroes with spaces
		    set data(formatted) [string replace $data(formatted) $i $i { }]
		    continue
		}
		{ } continue
		default break
	    }
	}
    }
}

# define the radio widget
# this one needs to be megawidget
# with configuration options for all the radio stuff
# so it needs to expose ui elements for:
#  1) frequency readout & tuning
#  2) mode selector option menu
#  3) filter selector option menu
#  4) host / service selection dialog
#  5) ...
snit::widgetadaptor ::ui::radio {
    variable data -array {
	connect {connect}
    }
    # the text for window title
    option -text -default {} -configuremethod Configure
    # the radio service selected
    option -service -default Amateur -configuremethod Configure
    # the band selected
    option -band -default 20m -configuremethod Configure
    # the frequency tuned
    option -frequency -default 14010000 -configuremethod Configure
    # the modulation
    option -mode -default CWU -type ::modes-type -configuremethod Configure
    # the filter shape
    option -filter -default {} -configuremethod Configure
    # the cw pitch
    option -cw-pitch -default {600} -configuremethod Configure
    # the dspserver name
    option -name -default {AD5DZ}
    # define a local server
    option -local -configuremethod Configure
    # delegates
    delegate method * to hull
    delegate option * to hull

    constructor args {
	installhull using ttk::frame
	$self configure {*}$args
	if {$::verbose > 1} { puts "ui::radio $win $args" }

	grid [ui::frequency-display $win.freq -frequency $options(-frequency)] -row 0 -column 1 -columnspan 6
	grid [ui::optionmenu $win.service -textvar [myvar options(-service)]] -row 1 -column 1
	grid [ui::optionmenu $win.band -textvar [myvar options(-band)]] -row 1 -column 2
	grid [ui::optionmenu $win.mode -textvar [myvar options(-mode)]] -row 1 -column 3
	grid [ui::optionmenu $win.filter -textvar [myvar options(-filter)]] -row 1 -column 4
	grid [ui::optionmenu $win.name -textvar [myvar option(-name)]] -row 1 -column 5
	grid [ttk::checkbutton $win.conn -width 10 \
		  -command [mymethod connecttoggle] \
		  -variable [myvar data(connect)] \
		  -onvalue {disconnect} -offvalue {connect} \
		  -textvar [myvar data(connect)]] -row 1 -column 6
	$win.service configure -values [sdr::band-data-services] -width [maxwidth [sdr::band-data-services]]
	$win.band configure -values [sdr::band-data-bands $options(-service)] -width [maxwidth [sdr::band-data-all-bands]]
	$win.mode configure -values [modes-type cget -values] -width [maxwidth [modes-type cget -values]]
	$win.filter configure -values [sdr::filters-get $options(-mode)] -width [maxwidth [sdr::filters-get-all]]
	$win.name configure -values [servers-names] -width 8
	servers-names-update [mymethod update-names]
    }
    method {Configure -text} {val} {
	set options(-text) $val
	wm title . $val
    }
    method {Configure -service} {val} { 
	set options(-service) $val
    }
    method {Configure -band} {val} { 
	if {$options(-band) eq $val} {
	    # to next memory in this band
	} else {
	    # band-save
	    set options(-band) $val
	    # band-restore
	}
	# $self configure -frequency xxx -mode xxx -filter xxx -agc xxx
    }
    method {Configure -frequency} {val} {
	if {$options(-frequency) != $val} {
	    set options(-frequency) $val
	    ::sdr::command::setfrequency [$self mode-offset-frequency]
	}
    }
    method {Configure -mode} {val} {
	if {$options(-mode) ne $val} {
	    set options(-mode) $val
	    ::sdr::command::setmode $val
	}
    }
    method {Configure -filter} {val} { 
	if {$options(-filter) ne $val} {
	    set options(-filter) $val
	    ::sdr::command::setfilter {*}[$self mode-offset-filter]
	}
    }
    method {Configure -agc} {val} {
	if {$options(-agc) ne $val} {
	    set options(-agc) $val
	    ::sdr::command::setagc $val
	}
    }
    method {Configure -cw-pitch} {val} {
	if {$options(-cw-pitch) != $val} {
	    set options(-cw-pitch) $val
	    ::sdr::command::setfrequency [$self mode-offset-frequency]
	    ::sdr::command::setfilter {*}[$self mode-offset-filter]
	}
    }
    method {Configure -name} {val} {
	if {[$self is-connected]} {
	    $self disconnect
	}
	puts "$self configure -name $val, with $win.name -values {[$win.name cget -values]}"
	set options(-name) $val
    }
    method {Configure -local} {val} {
	server-local-install {*}$val; # {name addr port}
    }
    method update-names {names} {
	# puts "update-names with $names"
	$win.name configure -values $names
	# puts "updated"
    }
    method connecttoggle {} {
	# the button label is already looking forward
	if {$::channel == -1} {
	    if {[catch {$self connect} error]} {
		set data(connect) {connect}
	    }
	} else {
	    if {[catch {$self disconnect} error]} {
		set data(connect) {disconnect}
	    }
	}
    }
    method connect {} {
	set ::channel [::ch::connect $self {*}[server-address-port $options(-name)]]
	::sdr::command::setclient tkradio
	::sdr::command::q-server
	# most of this should be done elsewhere
	# it resembles a band change
	::sdr::command::setfrequency [$self mode-offset-frequency]; # spectrum view follows
	::sdr::command::setmode $options(-mode)
	::sdr::command::setfilter {*}[$self mode-offset-filter]; # spectrum view follows
	# ui disable connect action
	# ui enable disconnect action
	# no, no, no $self connecttoggle, already done
	# ui enable subrx select
	# ui enable mute subrx 
	# ??? ::sdr::command::setpws $options(-pwsmode)
	## do we want to do audio on this channel?
	::sdr::command::setencoding 0
	# select local audio device
	::sdr::command::startaudiostream 2000 8000 1 0
	::sdr::command::setpan 0.5
	::sdr::command::setagc $options(-agc)
	# if we're going to muck with different spectra, ...
	# ::sdr::command::setpws $options(-pwsmode)
	# set these when the ANF, NR, or NB is enabled
	# ::sdr::command::setanfvals
	# ::sdr::command::setnrvals
	# ::sdr::command::setnbvals
	# ::sdr::command::setsquelchval
	# ::sdr::command::setsquelchstate
	# ::sdr::command::setanf
	# ::sdr::command::setnr
	# ::sdr::command::setnb
	# remote connected
	# ::sdr::command::setrxdcblock
	# ::sdr::command::settxdcblock
	# ::sdr::command::setrxagcslope # this one was disabled
	# ::sdr::command::setrxagcattack
	# ::sdr::command::setrxagcdecay
	# ::sdr::command::setrxagchang
	# ::sdr::command::setfixedagc
	# ::sdr::command::setrxagchangthreshold
	# ::sdr::command::settxlevelerstate
	# ::sdr::command::settxlevelermaxgain
	# ::sdr::command::settxlevelerattack
	# ::sdr::command::settxlevelerdecay
	# ::sdr::command::settxlevelerhang
	# ::sdr::command::setalcstate
	# ::sdr::command::settxalcattack
	# ::sdr::command::settxalcdecay
	# ::sdr::command::settxalchang
	# ::sdr::command::*hardware?
	# start spectrum
	switch $options(-mode) {
	    CWU - CWL {
		frequencyChanged $options(-frequency); # hack cw pitch offset into tuning
	    }
	}
	# enable notch filter false
	return 1
    }
    method disconnect {} { 
	if {[$self is-connected]} {
	    puts "disconnecting self = $self"
	    ::ch::disconnect $self $::channel
	    set ::channel -1
	    # stop spectrum timer (what spectrum timer?)
	    # set user none
	    # set passwrod none
	    # set host {}
	}
    }
    method is-connected {} { return [expr {$::channel != -1}] }
    method mode-offset-frequency {} {
	set f $options(-frequency)
	switch $options(-mode) {r
	    CWU { return [expr {$f - $options(-cw-pitch)}]}
	    CWL { return [expr {$f + $options(-cw-pitch)}]}
	    default { return $f }
	}
    }
    method mode-offset-filter {} {
	foreach {lo hi} [::sdr::filter-parse $options(-filter)] break
	set cw $options(-cw-pitch)
	switch $options(-mode) {
	    CWU { set lo [expr {$cw+$lo}]; set hi [expr {$cw+$hi}] }
	    CWL { set lo [expr {-$cw+$lo}]; set hi [expr {-$cw+$hi}] }
	}
	return [list $lo $hi]
    }
    method process-aspectrum {main sub sr lo spectrum} {
	puts stderr "spectrum $main $sub [string length $spectrum]"
    }
    method process-audio {audio} {
	puts stderr "audio [string length $audio]"
    }
    method process-answer {answer} {
	puts stderr "answer = {$answer}"
    }
}

set verbose 0

# start listing servers
servers-request

# build the radio
pack [set ::radio [ui::radio .r -text "tkradio"]] -fill both -expand true

# load configuration

# process arguments
proc optarg {opt} {
    upvar argc argc argv argv i i
    if {$i == $argc-1} { uplevel error "missing arg for $opt option" }
    $::radio configure $opt [lindex $argv [incr i]]
    if {$::verbose > 2} { puts "optarg $opt found [lindex $argv $i]" }
}
# specify options and create radios
for {set i 0} {$i < $argc} {incr i} {
    # accumulate arguments
    set opt [lindex $argv $i]
    switch -- $opt {
	-b - --band { optarg -band }
	-e - --filter { optarg -filter }
	-f - --frequency { optarg -frequency }
	-l - --local - --local-server { optarg -local }
	-m - --mode { optarg -mode }
	-n - --name - --name-of-server { optarg -name }
	-s - --service { optarg -service }
	-t - --text { optarg -text }
	-v - --verbose { incr ::verbose }
	-c - --connect { $::radio connect }
	default { error "unrecognized option [lindex $argv $i]" }
    }
}
