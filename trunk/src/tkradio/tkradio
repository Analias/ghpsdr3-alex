#!/usr/bin/tclsh
# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2016 by Roger E Critchlow Jr, Cambridge, MA, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

##
## required external packages
##
package require Tcl;		# sudo apt-get install tcl
package require snit;		# sudo apt-get install tcllib

##
## required internal packages
##
package require sdrtype::types;	# snit types for option checking
package require sdr::radio;	# the dspserver radio model
package require sdr::server;	# the napan.com servers listing
package require sdr::connect;	# the tcp connection to dspserver
#package require sdr::command;	# the commands sent to dspserver
package require sdr::audio;	# audio playback (no mike as yet)
#package require sdr::filter;	# our filter syntax
#package require sdr::util;	# various utilities

package require sdr::band-data;	# service and band information
package require sdr::memory;	# memories for the radio

snit::enum audio-format -values {ALAW:8000 PCM:48000}

snit::type tkradio {
    option -id -default {tkradio}
    option -ui -configuremethod Configure			
    option -hw -configuremethod Configure
    option -verbose -default 0 -configuremethod Configure2
    option -name -configuremethod Configure2
    option -name-values -configuremethod Configure2
    option -audio-format -default ALAW:8000 -type audio-format
    option -channel-status {}

    component server
    component connect
    
    component radio
    component hw
    component ui
    component hwui

    constructor {args} {
	install server using sdr::server $self.server -parent $self
	install connect using sdr::connect $self.connect -parent $self
	install radio using sdr::radio $self.radio -parent $self
	$radio configure -service [sdr::get-last service]
	$server request [list {*}[mymethod configure] -name-values]
	# initialize connections
	$connect add-listener status [mymethod channel-status]
	$connect add-listener spectrum [list $radio process-spectrum]
    }

    method {Configure -ui} {val} {
	if {$options(-ui) ne {}} {
	    # destroy the old ui
	}
	set options(-ui) $val
	if {[catch {package require sdrui::$val-radio} error]} {
	    puts stderr "cannot require package sdrui::$val-radio"
	    return
	}

	# source sdr/theme-alt.tcl
	ttk::style theme create night
	if {[catch {package require ttk::theme::night} error]} {
	    puts stderr "cannot require package ttk::theme::night"
	} else {
	    ttk::style theme use night
	}
	pack [sdrui::$val-radio .radio -parent $self] -fill both -expand true
	set ui .radio
    }

    method {Configure -hw} {value} {
	if {$options(-hw) ne $value} {
	    if {$options(-hw) eq {} && $value ne {}} {
		# load hardware component
		set hardware sdr::radio-$value
		if {[catch {package require $hardware} error]} {
		    # no such hardware module
		    puts stderr "package require $hardware failed: $error"
		    return
		}
		# initialize hardware component, 
		if {[catch {$hardware $self.hw -parent $self} error]} {
		    # failed to create hardware handler
		    puts stderr "$hardware -radio $self failed: $error"
		    return
		}
		# mark it as installed
		set options(-hw) $value
		set hw $self.hw

		# now do the matching ui component
		# if there is one!
		if {$options(-ui) ne {}} {
		    $self install-hwui
		}
	    } elseif {$options(-hw) ne {} && $value eq {}} {
		set options(-hw) $value
		catch {rename $hw {}}
		set hw {}

		$ui unmap-hardware
		destroy $hwui
		set hwui {}
	    } else {
		puts stderr "Configure -hw {$value} when options(-hw) is {$options(-hw)}???"
	    }
	}
	
    }

    method Configure2 {option value} {
	if {$options($option) ne $value} {
	    set options($option) $value
	}
    }

    method install-hwui {} {
	set hardwareui sdrui::$options(-ui)-radio-$options(-hw)
	# load hardware ui package
	if {[catch {package require $hardwareui} error]} {
	    # no such hardware ui module
	    puts stderr "package require $hardwareui failed: $error"
	    return
	}
	# create hardware ui widget
	if {[catch {$hardwareui $ui.hw -parent $self} error]} {
	    puts stderr "$hardwareui $ui.hw -parent $self failed: $error"
	    return
	}
	# map it into the ui
	if {[catch {$ui map-hardware} error]} {
	    puts stderr "$hardwareui failed to map"
	    rename $ui.hw {}
	    return
	}
	# save the component
	set hwui $ui.hw
    }

    method verbose-puts {msg} {
	if {$options(-verbose)} { puts stderr $msg }
    }
    method get-audio-sample-format {} {
	return [lindex [split $options(-audio-format) :] 0]
    }
    method get-audio-sample-rate {} {
	return [lindex [split $options(-audio-format) :] 1]
    }
    ##
    method connect {} {
	if {[$connect is-connected]} { error "socket is already connected" }
	$connect connect {*}[$server address-port $options(-name)]
	$connect add-listener audio audio-out-data
	audio-out-start [$self get-audio-sample-format] [$self get-audio-sample-rate]
    }

    method disconnect {} {
	if { ! [$connect is-connected]} { error "socket is not connected" }
	# verbose-puts "disconnecting self = $self"
	$connect disconnect
	$connect sub-listener audio audio-out-data
	audio-out-stop
    }
    # toggle the connection state
    method connecttoggle {} {
	if { ! [$connect is-connected]} {
	    if {[catch {$radio connect} error]} {
		puts stderr "error in connect: $error\n$::errorInfo"
		$self channel-status $error
	    } else {
		$self channel-status {connected}
	    }
	} else {
	    if {[catch {$radio disconnect} error]} {
		puts stderr "error in disconnect: $error\n$::errorInfo"
		$self channel-status $error
	    } else {
		$self channel-status {disconnected}
	    }
	}
	return [$connect is-connected]
    }
    method channel-status {status} {
	switch $status {
	    * {
		puts stderr "channel status: $status"
		$self configure -channel-status {unknown error}
		# $radio disconnect
	    }
	}
    }
    

    ##
    ## monitor our configuration options
    ## 
    method monitor {opts prefix} {
	foreach opt $opts {
	    trace variable options($opt) w [list {*}[mymethod monitor-fired] $prefix]
	}
    }
    method monitor-fired {prefix name1 name2 op} {
	{*}$prefix $name2 $options($name2)
    }

    # process a command line argument
    method optarg {opt} {
	upvar argc argc argv argv i i
	if {$i == $argc-1} { 
	    set list {}
	    switch -- $opt {
		-audio-format { set list {ALAW:8000 PCM:48000} }
		-server { set list [$server get-names] }
		-service { set list [sdr::band-data-services] }
		-band { set list [$radio cget -band-values] }
		-mode {	set list [$radio cget -mode-values] }
		-filter { set list [$radio cget -filter-values] }
	    }
	    if {$list ne {}} {
		set e "missing arg for $opt option: $list"
	    } else {
		set e "missing arg for $opt option"
	    }
	    error $e
	}
	set val [lindex $argv [incr i]]
	# $self verbose-puts "optarg $opt found $val"
	switch -- $opt {
	    -local { $server add-local {*}$val }
	    default { $self configure $opt $val }
	}
    }

    # process command line arguments to the tkradio script
    method process-argv {argv} {
	if {[catch {
	    set argc [llength $argv]
	    # load saved configuration, including current options, saved memories,
	    # and last tuned points
	    
	    # specify options
	    for {set i 0} {$i < $argc} {incr i} {
		# accumulate arguments
		set opt [lindex $argv $i]
		switch -- $opt {
		    --					{ continue }
		    -a - --audio-format			{ $self optarg -audio-format }
		    -b - --band				{ $self optarg -band }
		    -c - --connect			{ $self.radio connect }
		    -e - --filter			{ $self optarg -filter }
		    -f - --frequency			{ $self optarg -frequency }
		    -l - --local - --local-server	{ $self optarg -local }
		    -m - --mode				{ $self optarg -mode }
		    -n - --name - --name-of-server	{ $self optarg -name }
		    -s - --service			{ $self optarg -service }
		    -t - --text				{ $self optarg -text }
		    -u - --ui				{ $self optarg -ui }
		    -v - --verbose			{ $self optarg -verbose }
		    default { error "unrecognized option [lindex $argv $i]" }
		}
	    }
	} error]} {
	    if {$options(-verbose)} {
		puts stderr $error\n$::errorInfo\n$usage 
	    } else {
		puts stderr $error$usage
	    }
	    exit 1
	}
    }
    #
    # also want
    #  audio-format ALAW or PCM
    #  audio-sample-rate 8000 or 48000
    #
    variable usage {
usage: tkradio -- <option> [<value>] ...
    --
    -a|--audio-format <format> # is ALAW:8000 or PCM:48000
    -b|--band <band> # <band> is a <service> specific band name
    -c|--connect
    -e|--filter <filter> # <filter> in form 'low .. high'
    -f|--frequency <frequency> # <frequency> in Hertz
    -l|--local|--local-server <local> # <local> in form 'name ip-address port' 
    -m|--mode <mode> # <mode>
    -n|--name|--name-of-server <name> # <name> the name or callsign of a dspserver
    -s|--service <service> # 
    -t|--text <text>
    -u|--ui <ui>
    -v|--verbose <level>
}

}

# create an instance with an automatic name
set tkr [tkradio %AUTO%]
# define a global message reporter
proc verbose-puts {msg} "$tkr verbose-puts \$msg"
# process the command line arguments
$tkr process-argv $argv
